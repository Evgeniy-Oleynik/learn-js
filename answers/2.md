## Задача/Вопрос 1
```js
let countriesList = {
    Ukraine: {
        square: 603.628,
        population: 44.13e6,
    },
    Uruguay: {
        square: 176.215,
        population: 3.474e6,
    },
}
```

## Задача/Вопрос 2
```js
1. console.log(3);

2. console.log(obj.a.b);
```

## Задача/Вопрос 3
```js
obj.a.c = 4;
```

## Задача/Вопрос 4
```js
delete obj.a.b;
```

## Задача/Вопрос 5
```js
for (let key in obj) {
    console.log(key);
}
```

## Задача/Вопрос 6
```js
for (let key in obj) {
    if (typeof obj[key] == 'number') {
        console.log(obj[key])
    }
}
```

## Задача/Вопрос 7
```js
function checkKey(obj, key) {
   return !!obj[key];
}
```

## Задача/Вопрос 8
```js
let obj = {
    [TOTAL]: Math.round(Math.random() * 100),
    [WIDTH]: Math.round(Math.random() * 100),
    [HEIGHT]: Math.round(Math.random() * 100),
}
```

## Задача/Вопрос 9
```
1. Да.
2. Потому что в обоих случаях "undefined" воспринимается как имя ключа и они оба ссылаются на 1.  
```

## Задача/Вопрос 10
```js
let allSum = 0;
let peopleCounter = 0;
for (let key in salaries) {
    allSum += salaries[key];
    peopleCounter++;
}
console.log(allSum / peopleCounter);
```

## Задача/Вопрос 11
```
Нет. Потому что это разные объекты, не смотря на идентичное наполнение.
```

## Задача/Вопрос 12
```
Да. Потому что обе переменные ссылаются на один и тот же объект.
```

## Задача/Вопрос 13
```
1. 'Bob'.
2. Потому что обе переменные firstUser и secondUser ссылаются на один и тот же объект. 
```

## Задача/Вопрос 14
```
1. age: 25, height: 180.
2. Да.
3. Потому что profile внутри firstUser является объектом в объекте. secondUser целиком ссылается на тот же объект, что и firstUser.
profile ссылается на объект внутри объекта, как и firstUser.profile и secondUser.profile.
```

## Задача/Вопрос 15
```
Если объявить profile через const:
1. age: 25
2. Будет ошибка из-за попытки перезаписать константу.

Если объявить profile через let:
1. age: 25
2. В последней строке переменной profile присваивается новый пустой объект.
firstUser.profile и secondUser.profile остаются без изменений.
```

## Задача/Вопрос 16
```
1. age = 30, firstUser.profile.age = 25, secondUser.profile.age = 25.
2. Нет.
3. Потому что, в отличии от задания 14, secondUser.profile.age не является объектом.
И переменная age не ссылается на объеrт, а ей присваивается значение secondUser.profile.age.
```

## Задача/Вопрос 17
```js
//  1
const user = {
    getFirstName(str)  {
        return str ? str : 'empty';
    },
}
```

## Задача/Вопрос 18
```js
const user = {
    firstName: 'John',
    lastName: 'Smith',

    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
};

const fullName = user.getFullName();
console.log(fullName);
```

## Задача/Вопрос 19
```js
const user = {
    name: 'John',

    user() {
        return this;
    }
}
const name = user.user().user().user().user().user().user().name;
console.log(name);
```

## Задача/Вопрос 20
```js
const userWithName = new User('Mike');
const firstName = userWithName.getFirstName();
console.log(firstName);

const userWithoutName = new User();
const emptyName = userWithoutName.getFirstName();
console.log(emptyName);

function User(name = 'empty') {
    this.name = name;
    this.getFirstName = function() {
        return this.name;
    }
}
```

## Задача/Вопрос 21
```js
const User = function() {
    this.firstName = 'John';
    this.lastName = 'Smith';

    this.getFullName = function() {
        return `${this.firstName} ${this.lastName}`
    };
};

const user = new User();
const fullName = user.getFullName();
console.log(fullName);
```

## Задача/Вопрос 22
```js
const User = function() {
    this.name = 'John';

    this.user = function() {
        return this;
    }
}

const user = new User();
const name = user.user().user().user().user().user().user().name;
console.log(name);
```

## Задача/Вопрос 23
```js
const user = {
  firstName: 'John',
  profile: {
    age: 25,
  },
};

const height = user.profile.height?.();
console.log(height);
```
